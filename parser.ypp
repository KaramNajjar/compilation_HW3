%{

	#include "output.hpp"
	#include "parser.hpp"
	#include <typeinfo>
	#include <string.h>
	#include <stdbool.h>
	#include <stack> 
	#include <iostream>
	using namespace std;
	using namespace output;

	int yyerror(string message);
	extern int yylineno;
	extern int yylex();

	typedef struct  {
		string name;
		EType type;
		int offset;
		list<EType> params;  // only used for functions
		EType retType; 		// only used for functions
		bool isFunc;
	}elementData;
	
	list<list<elementData> > vartable;
	stack<int> offsets;

	bool isLegalCoersion(EType type1,EType type2);
	bool checkFuncArgs(list<EType> decleration,list<ExpNode*>* callparams);
	std::vector<string> ListToVector(const list<EType> list);
	bool expListExist = false;
	int mainFuncsCounter = 0;

%}

%left AND
%left OR
%left RELOP
%left BINOP


%token VOID
%token INT
%token BYTE
%token B
%token BOOL

%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF

%token WHILE
%token SWITCH
%token CASE
%token DEFAULT
%token BREAK
%token COLON
%token SC
%token COMMA
%token LPAREN
%nonassoc RPAREN
%token LBRACE
%token RBRACE
%token ASSIGN


%token NUM
%token ID
%token STRING

%nonassoc ELSE

%%



Prog : Funcs 
	{
		//IDK what to write here...
		if(mainFuncsCounter < 1)
			errorMainMissing();
	}
	
Funcs 
	: {/*$$ = new FuncsListNode();*/}
	| FuncDecl Funcs 
	{
		FuncNode* currFunc = (FuncNode*)$1;
		FormalsListNode* currFormalsList = currFunc->formalsNode->formalsListNode;
		if(((IdNode*)currFunc->id)->id == "main" && currFunc->retType->retType == E_VOID && currFormalsList->formalDecls->empty())
		{
			mainFuncsCounter++;
			if(mainFuncsCounter > 1)
				errorMainMissing();// Delete this and Threw an appropirate error...
		}
		
		if($2 == NULL)
			$2 = new FuncsListNode();
		
		$$ = (FuncsListNode*)$2;
		((FuncsListNode*)$$)->funcsList->push_back(*currFunc);
	} 

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statments RBRACE
		{
			// Check if return Statments return the appropirate type
			// Check Formals IDs conflict
		}
		
RetType : Type {$$ = (RetTypeNode*)$1;}
		| VOID {$$ = new VoidTypeNode();}
		
Formals : FormalsList {$$ = new FormalsNode((FormalsListNode*)$1);}
		| {}
		
FormalsList : FormalDecl {  }
			| FormalDecl COMMA FormalsList
			{
				FormalDeclNode* currFormalDecl = (FormalDeclNode*)$1;
				
				if($3 == NULL)
					$3 = new FormalsListNode();
		
				$$ = (FormalsListNode*)$2;
				((FormalsListNode*)$$)->formalDecls->push_back(*currFormalDecl);
			}
			
FormalDecl : Type ID { $$ = new FormalDeclNode((TypeNode*)$1,(IdNode*)$2);}

Statments : ID {  }

	
Call : ID LPAREN ExpList RPAREN	//First_Finish
	{
		$$ = new CallNode((IdNode*)$1);
		//if(ID exist)
		{
			//elementData entry=get_exists_variable(vartable,$1.name);
			
		//if(entry->type != E_FUNC)
			{
				errorUndefFunc(yylineno,((IdNode*)$1)->id.c_str());
				exit(1);
			}
		//	if(checkFuncArgs(entry.params,$3.params) == false )
		{
				//errorPrototypeMismatch(yylineno,$1->id.c_str(),ListToVector(entry.params));
				exit(1);
			}
			//$$->type = entry.retType;
		}
		//else
		{
			$$->type = E_VOID;
			if(((IdNode*)$1)->id == "print"){
				//print function
					list<EType> l = list<EType>();
					l.push_back(E_STRING);
				if(!checkFuncArgs(l,((ExpListNode*)$3)->params))
				{
					vector<string> v = vector<string>();
					v.push_back("STRING");
					errorPrototypeMismatch(yylineno,((IdNode*)$1)->id.c_str(),v);
					exit(1);
				}
			}else if(((IdNode*)$1)->id == "printi")  {
				//printi function
				list<EType> l = list<EType>();
				l.push_back(E_INTEGER);
				if(!checkFuncArgs(l,((ExpListNode*)$3)->params)){
					
					vector<string> v = vector<string>();
					v.push_back("INT");
					
					errorPrototypeMismatch(yylineno,((IdNode*)$1)->id.c_str(),v);
					exit(1);
				}
				
			}else{
				errorUndefFunc(yylineno,((IdNode*)$1)->id.c_str());
				exit(1);
			}
		}
	
		
	};
	| ID LPAREN RPAREN //First_Finish
		{
		//if(isExist(vartable,$1.name) != 1 )
		{
			errorUndefFunc(yylineno,((IdNode*)$1)->id.c_str());
			exit(1);
		}
		//elementData entry=get_exists_variable(vartable,$1.name.c_str());
		//if(entry.type != E_FUNC)
		{
			errorUndefFunc(yylineno,((IdNode*)$1)->id.c_str());
			exit(1);
		}
		//if(entry.params.size() != 0)
		{
			//errorPrototypeMismatch(yylineno,((IdNode*)$1)->id.c_str(),ListToVector(entry.params));
			exit(1);
		}
		//$$.type = entry.retType;
		
		}

ExpList: Exp COMMA ExpList  //First_Finish
		{
			$$ = $2;
			(((ExpListNode*)$$)->params)->push_front((ExpNode*)$1);
		};
		|Exp
		{
			$$ = new ExpListNode();
			(((ExpListNode*)$$)->params)->push_front((ExpNode*)$1);
		};
		
Type 	: 	INT 	{$$ = new TypeNode(E_INTEGER);} //First_Finish
		|	BYTE  	{$$ = new TypeNode(E_BYTE);}
		|	BOOL 	{$$ = new TypeNode(E_BOOLEAN);};
		
Exp : LPAREN Exp RPAREN { $$ = $2; }
		
	| Exp BINOP Exp //First_Finish
		{ 
			cout << "Binop exp started " << endl;
			
			
			if((((ExpNode*)$1))->type != E_INTEGER && (((ExpNode*)$1))->type != E_BYTE)
			{
				errorMismatch(yylineno);
				exit(1);
			}
			if((((ExpNode*)$1))->type != (((ExpNode*)$3))->type)
			{
				errorMismatch(yylineno);
				exit(1);
			}
			
			$$ = new BinExpNode(((ExpNode*)$1),(BinOpNode*)$2,((ExpNode*)$3)); 
			((ExpNode*)$$)->type = (((ExpNode*)$1))->type;
			
			cout << "Binop exp finished" << endl;

		}
		
	| ID //First_Finish
		{
			cout << "ID exp started" << endl;
			if(isExist($1->id) == false){
						errorUndef(yylineno,$1.name.c_str());
						exit(1);
			}
			// check if identefier type is legal
			elementData eData = get_exists_element($1->id)
			if(eData->isFunc)
			{
				errorUndef(yylineno,$1.name.c_str());
				exit(1);
			}
				
			
			$$ = new IdExpNode((IdNode*)$1); 
			cout << "ID exp finished" << endl;
		}
	| Call //First_Finish , not sure
		{
			if($1->type == E_VOID){
				errorMismatch(yylineno);
				exit(1);
			}
			// Get funcDecl by Id and Check RetType of FuncDecl
			$$->type = $1->type;
		}
	| NUM //First_Finish
		{ 
			cout << "NUM exp started" << endl;
			
			$$ = new NumExpNode((NumNode*)$1); 
			
			cout << "NUM exp finished" << endl;

		}
		
	| NUM B //First_Finish
		{
			cout << "NUM B exp started" << endl;

			if(((NumNode*)$1)->num > 255){
				string str = "" + ((NumNode*)$1)->num;
				errorByteTooLarge(yylineno,str.c_str());
				exit(1);
			}
			$$ = new NumBExpNode((NumNode*)$1); 
			
			cout << "NUM B exp finished" << endl;

		}

	| STRING //First_Finish
		{
			cout << "String exp started" << endl;
			$$ = new StringExpNode((StringNode*)$1); 
			cout << "String exp finished" << endl;
		}
		
		
	| TRUE		{$$ = new BoolExpNode((BoolNode*)$1);}//First_Finish	
	| FALSE		{$$ = new BoolExpNode((BoolNode*)$1);}//First_Finish
	| NOT Exp	//First_Finish
		{
			if((((ExpNode*)$2))->type != E_BOOLEAN){
				errorMismatch(yylineno);
				exit(1);
			 }
			$$ = new NotExpNode(((ExpNode*)$2));
		}
	| Exp OR Exp  //First_Finish
		{
			if(((ExpNode*)$1)->type != E_BOOLEAN || ((ExpNode*)$3)->type != E_BOOLEAN ){
				errorMismatch(yylineno);
				exit(1);
			 }
			 $$ = new ExpNode(E_BOOLEAN);
		}
	| Exp AND Exp //First_Finish
		{
			if(((ExpNode*)$1)->type != E_BOOLEAN || ((ExpNode*)$3)->type != E_BOOLEAN ){
				errorMismatch(yylineno);
				exit(1);
			 }
			 $$ = new ExpNode(E_BOOLEAN);
		}
	| Exp RELOP Exp	//First_Finish
		{
			if(((ExpNode*)$1)->type != E_INTEGER || ((ExpNode*)$3)->type != E_INTEGER ){
				errorMismatch(yylineno);
				exit(1);
			 }
			 $$ = new ExpNode(E_BOOLEAN);
		};
	

%%

int main()
{
	cout << "Main: " << endl;
	int result = yyparse();
	return result ; 
}

int yyerror(string message)
{
	cout << "Error: " << endl;
	errorSyn(yylineno);
	exit(1);
}

bool isLegalCoersion(EType fromType , EType toType)
{
	if((fromType == E_UNDEFINED) || (toType == E_UNDEFINED) ) {
		std::cout << "error in isLegalCoersion " << std::endl;
		exit(1);
	}
	if(fromType == toType) return true;
	if((fromType == E_BYTE) && (toType == E_INTEGER) ) return true;
	return false;
}

std::vector<string> ListToVector(const list<EType>  list )
{
	std::vector<string> vec ;
	for(std::list<EType>::const_iterator it= list.begin(); it!= list.end();++it){
		string var_type  ;
		switch(*it){
			case E_INTEGER : var_type = "INT";
							break;
			case E_BOOLEAN : var_type = "BOOL";
							break;
			case E_BYTE :	 var_type = "BYTE";
							break;
			case E_STRING : var_type = "STRING";
							break;
			default : 
					std::cout << "error in ListToVector undefined variable"<<std::endl;
					exit(1);
		}
		vec.push_back(var_type);
	}
	return vec;
}

bool isExist(string elementName)
{
	list<list<elementData> >::const_iterator end = vartable.end();
	for(list<list<elementData> >::const_iterator element = vartable.begin()  ; element!=end ;  element++ )
	{
		list<elementData>::const_iterator lend = (*element).end();
		for(list<elementData>::const_iterator lentry = (*element).begin()  ; lentry != lend ; lentry++)
		{
			if((*lentry).name == elementName ) 
				return true ;
		}
	}
	return false ; 
}
elementData get_exists_element(string elementName){
	
	list<list<elementData> >::const_iterator end = vartable.end();
	for(list<list<elementData> >::const_iterator element = vartable.begin()  ; element!=end ;  element++ )
	{
		 list<elementData>::const_iterator lend = (*element).end();
		for(list<elementData>::const_iterator elementData = (*element).begin()  ; elementData != lend ; elementData++)
		{
			if((*elementData).name == elementName ) 
				return (*elementData) ;
		}
	}
}

bool checkFuncArgs(list<EType> decleration,list<ExpNode*>* callparams){

	if(decleration.size() != callparams->size()) return false;
	list<ExpNode*>::const_iterator element2 = callparams->begin();
	for(list<EType>::const_iterator element = decleration.begin()  ; element!=decleration.end() ;  ++element ,++element2)
	{	
		if(!isLegalCoersion((*element2)->expType,*element)) return false;
	}
	return true;
}

//bool checkExpBinOpTypes(ExpNode e1, ExpNode e2)
//{
//	if(typeid(e1).hash_code() == typeid(NumExpNode*).hash_code() || typeid(e1).hash_code() == typeid(NumBExpNode*).hash_code())
//		if(typeid(e1).hash_code() == typeid(e2).hash_code())
//			return true;
//	
//	return false;
//}

